Building Doker images

Anybody can make images from scratch, but it is not easy to craete images with sufficient quality and security for production 
Developesr create their own images, however the building pocess usually starts with a previous image
All image build processes wil start with a FROM statement. THis indicates the previous image 

3 Ways of creating an image
1) Using a file with instrucinos (DOckerfile)
2) Interacting with files in different container layers, execurint one container, modifying its content, and then storing the changes made
3) Using an empty layer, and adding components by hand, file by file, also known as craeting an image from scratch 

Dockerfiles
    - First uses abase image, to build the environment, If the image is not presetn, the Docker daemon will download its layers automatically 
    - Using the downloaded layesr, docker will automaticaly run a container using this image, and execute the declared commands 
    - After software installation, Docker will execute a docker container commmit command internally to persist these changes on the new layer in order to use them as a base forthe next step 
    - A container is alawys created using an image as a tempate.
    - A Dockerfile describes a reusable process 

Creating Images Ineractively 
    - Tis is done by running a conatiner, and making change son the fly to rootfs
    - This is very useful when an applicatinos installation cannot be automated, but lacks reproducibility 
        1) Start an interactve container $ docker container run -ti debian 
        2) install and update relevant packages $ apt-get update -qq 
        3) you can exit the container once done $ exit 
        4) We've exited the current main process, and as a result retunred to our host. We will now look for the last conatiner that was executed on our host, then save the container layer as the new image layer 
            $ docker container ls -l 
            $ docker container commit hash container-name 

Creating Images from scratch 
    - This is the most effective method 
    - You can use a Dockerfile as described above, but the inital base image will be an empty reserved one, known literlly as "scratch" 
    - Scratch is not a real imag,e it only contains the root filesystem structure and its meta-information 
    - Images built using this method must container all binaries, libraries, and files required by our proess 

Image tagging and meta-information 
    - Using labels it is easy to search for specific images by environment, eg: 
        $ docker image ls --filter label=environment
        $ docker image ls --filter label=environment=test
    Docker images can have many names, so removing an image by its name, does not really remove the image if it is in use by other names 
    If we use its image ID to remove, the docker daemon will inform us about multple images with different names using the same layers, 
    and will not delete the image nless we use --force 

    $ docker rmi (this is an alias for docker image rm )
    $ docker image prune  (this removes dangling images)
        -> A dangling image is a build of an image that hasn't been given a name 